<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
var names =   new []{"Int8" , "Uint8", "Uint8Clamped", "Int16", "Uint16" , "Int32", "Uint32", "Float32", "Float64"};
var types =   new []{"byte" , "byte" , "byte"        , "short", "ushort" , "int"  , "uint"  , "float"  , "double" };
#>
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.WindowsRuntime;
using Windows.Foundation.Metadata;
using Windows.Storage.Streams;

namespace Opportunity.ChakraBridge.UWP
{
<#
for(var i = 0; i < names.Length; i++)
{
    var name = names[i];
    var type = types[i];
#>

    /// <summary>
    /// A Javascript <#=name#>Array.
    /// </summary>
    public unsafe sealed class Js<#=name#>Array : JsTypedArray, IList<<#=type#>>
    {
        internal Js<#=name#>Array(JsValueRef reference, JsTypedArrayType type, void* buffer, long bufferLength) 
            : base(reference, type, BytesPerElement, buffer, bufferLength) { }

        /// <summary>
        /// Create new instance of <see cref="Js<#=name#>Array"/>.
        /// </summary>
        /// <returns>A new instance of <see cref="Js<#=name#>Array"/>.</returns>
        [Overload("CreateEmpty")]
        public static new Js<#=name#>Array Create()
            => (Js<#=name#>Array)FromRef(RawArray.CreateTyped(JsTypedArrayType.<#=name#>, JsValueRef.Invalid, 0, 0));

        /// <summary>
        /// Create new instance of <see cref="Js<#=name#>Array"/>.
        /// </summary>
        /// <param name="length">Length of array.</param>
        /// <returns>A new instance of <see cref="Js<#=name#>Array"/>.</returns>
        [DefaultOverload]
        [Overload("CreateWithLength")]
        public static Js<#=name#>Array Create(int length)
        {
            if (length < 0)
                throw new ArgumentOutOfRangeException(nameof(length));
            return (Js<#=name#>Array)FromRef(RawArray.CreateTyped(JsTypedArrayType.<#=name#>, JsValueRef.Invalid, 0, (uint)length));
        }

        /// <summary>
        /// Create new instance of <see cref="Js<#=name#>Array"/>.
        /// </summary>
        /// <param name="typedArray">The array to copy values into the new array.</param>
        /// <returns>A new instance of <see cref="Js<#=name#>Array"/>.</returns>
        [Overload("CreateWithTypedArray")]
        public static Js<#=name#>Array Create(JsTypedArray typedArray)
        {
            if (typedArray is null)
                throw new ArgumentNullException(nameof(typedArray));
            return (Js<#=name#>Array)FromRef(RawArray.CreateTyped(JsTypedArrayType.<#=name#>, typedArray.Reference, 0, 0));
        }

        /// <summary>
        /// Create new instance of <see cref="Js<#=name#>Array"/>.
        /// </summary>
        /// <param name="obj">The <see cref="JsObject"/> to convert to array.</param>
        /// <returns>A new instance of <see cref="Js<#=name#>Array"/>.</returns>
        [Overload("CreateWithObject")]
        public static Js<#=name#>Array Create(JsObject obj)
        {
            if (obj is null)
                throw new ArgumentNullException(nameof(obj));
            return (Js<#=name#>Array)FromRef(RawArray.CreateTyped(JsTypedArrayType.<#=name#>, obj.Reference, 0, 0));
        }

        /// <summary>
        /// Create new instance of <see cref="Js<#=name#>Array"/>.
        /// </summary>
        /// <param name="buffer">The <see cref="JsArrayBuffer"/> that the array will be based on.</param>
        /// <returns>A new instance of <see cref="Js<#=name#>Array"/>.</returns>
        [Overload("CreateWithArrayBuffer")]
        public static Js<#=name#>Array Create(JsArrayBuffer buffer)
            => Create(buffer, 0);

        /// <summary>
        /// Create new instance of <see cref="Js<#=name#>Array"/>.
        /// </summary>
        /// <param name="buffer">The <see cref="JsArrayBuffer"/> that the array will be based on.</param>
        /// <param name="byteOffset">The offset of the created array to <paramref name="buffer"/>.</param>
        /// <returns>A new instance of <see cref="Js<#=name#>Array"/>.</returns>
        [Overload("CreateWithArrayBufferAndOffset")]
        public static Js<#=name#>Array Create(JsArrayBuffer buffer, int byteOffset)
            => Create(buffer, byteOffset, (buffer.Count - byteOffset) / BytesPerElement);

        /// <summary>
        /// Create new instance of <see cref="Js<#=name#>Array"/>.
        /// </summary>
        /// <param name="buffer">The <see cref="JsArrayBuffer"/> that the array will be based on.</param>
        /// <param name="byteOffset">The offset of the created array to <paramref name="buffer"/>.</param>
        /// <param name="length">Length of array.</param>
        /// <returns>A new instance of <see cref="Js<#=name#>Array"/>.</returns>
        [Overload("CreateWithArrayBufferAndLength")]
        public static Js<#=name#>Array Create(JsArrayBuffer buffer, int byteOffset, int length)
        {
            if (buffer is null)
                throw new ArgumentNullException(nameof(buffer));
            return (Js<#=name#>Array)FromRef(RawArray.CreateTyped(JsTypedArrayType.<#=name#>, buffer.Reference, byteOffset, length));
        }

        /// <summary>
        /// Returns a number value of the element size for the different typed array objects.
        /// </summary>
        public static int BytesPerElement => sizeof(<#=type#>);

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private <#=type#>* Pointer => (<#=type#>*)this.Buffer;

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        bool ICollection<<#=type#>>.IsReadOnly => false;
        
        /// <inheritdoc/>
        public <#=type#> this[int index]
        {
            get
            {
                if (unchecked((uint)index >= (uint)Count))
                    throw new ArgumentOutOfRangeException(nameof(index));
                return Pointer[index];
            }
            set
            {
                if (unchecked((uint)index >= (uint)Count))
                    throw new ArgumentOutOfRangeException(nameof(index));
                Pointer[index] = value;
            }
        }
        
        /// <inheritdoc/>
        public int IndexOf(<#=type#> item)
        {
            var start = Pointer;
            var end = start + Count;
            for (var p = start; p < end; p++)
            {
                if (*p == item)
                    return (int)(p - start);
            }
            return -1;
        }
        /// <inheritdoc/>
        public bool Contains(<#=type#> item) => IndexOf(item) >= 0;
        /// <inheritdoc/>
        public void CopyTo(<#=type#>[] array, int arrayIndex)
        {
            if (array is null)
                throw new ArgumentNullException(nameof(array));
            if (arrayIndex < 0 || array.Length < arrayIndex + Count)
                throw new ArgumentOutOfRangeException(nameof(arrayIndex));
            fixed (<#=type#>* dst = &array[arrayIndex])
            {
                System.Buffer.MemoryCopy(this.Buffer, dst, (array.Length - arrayIndex) * BytesPerElement, this.BufferLength);
            }
        }
        /// <summary>
        /// Copy data of this array to a new array.
        /// </summary>
        /// <returns>A copy of this array.</returns>
        public <#=type#>[] ToArray()
        {
            if (Count == 0)
                return Array.Empty<<#=type#>>();
            var r = new <#=type#>[Count];
            CopyTo(r, 0);
            return r;
        }
        /// <inheritdoc/>
        public IEnumerator<<#=type#>> GetEnumerator() => ((IEnumerable<<#=type#>>)ToArray()).GetEnumerator();
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
        
        /// <summary>Invalid operation.</summary>
        /// <exception href="InvalidOperationException">The array is fixed size.</exception>
        public void Insert(int index, <#=type#> item) => throw new InvalidOperationException("The array is fixed size.");
        /// <summary>Invalid operation.</summary>
        /// <exception href="InvalidOperationException">The array is fixed size.</exception>
        public void RemoveAt(int index) => throw new InvalidOperationException("The array is fixed size.");
        /// <summary>Invalid operation.</summary>
        /// <exception href="InvalidOperationException">The array is fixed size.</exception>
        public void Add(<#=type#> item) => throw new InvalidOperationException("The array is fixed size.");
        /// <summary>Invalid operation.</summary>
        /// <exception href="InvalidOperationException">The array is fixed size.</exception>
        public void Clear() => throw new InvalidOperationException("The array is fixed size.");
        /// <summary>Invalid operation.</summary>
        /// <exception href="InvalidOperationException">The array is fixed size.</exception>
        public bool Remove(<#=type#> item) => throw new InvalidOperationException("The array is fixed size.");
    }
<#
}
#>
}